<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>The Accessibility Tree: A Training Guide for Advanced Web Development</title>
<meta name="Author" content="Bryan Garaventa" />
<link rel="stylesheet" type="text/css" href="css/_global.css" />
<script type="text/javascript" src="http://whatsock.com/Acc.DC.API.js"></script>
<script type="text/javascript" src="js/footnote_generator.js"></script>
<script type="text/javascript" src="js/setup.js"></script>
</head>
<body>
<div>

<div class="menuLinks">
<div class="logo">
<a href="http://whatsock.com/">
<img title="WhatSock : Changing the world one step at a time" alt="WhatSock : Changing the world one step at a time" src="img/whatsock_logo.jpg" />
</a>
</div>
</div>

<div class="hd">
<h1>
<span>
The Accessibility Tree: A Training Guide
</span>
</h1>
</div>

<div role="navigation" class="intro announce" id="ph"></div>

<div class="cb" id="pgContent">
<div id="pg-intro">

<div class="intro heading">
<p>
Last modified: <span class="accFootnote" data-footnote="f1">09/02/2014</span>
</p>
<p>
From the end user perspective, accessibility is always simple. Shades of accessibility aside for whoever is attempting to interact with the desired functionality, either it works as they expect, or it does not. When it doesn't, it always gets bounced back to developers, and officially becomes Somebody Else's Problem.
</p>
<p>
As a developer, it's taken me many years to figure out that there are several very important layers to accessibility for web technologies, and how to recognize them during the process of development. It took my involvement with the <a href="http://www.w3.org/WAI/about.html" target="_blank">WAI Protocols and Formats Working Group</a> to really cement these concepts into place for me, and to put things into perspective. It really should not have to be this difficult though, not for me, or anybody else. This is especially true for developers, upon whose proverbial head all accessibility issues eventually land.
</p>
<p>
So my goal with writing this, is to provide a single comprehensive explanation of what these layers of accessibility are, and how developers can recognize them during the process of development, so that accessible web technologies will be easier to diagnose and build in the future.
</p>
<p>
This also describes the methodology that I use personally to build and test new web technologies. It's the culmination of many years of study.
</p>
</div>

<div role="region" aria-label="Accessibility API">

<div class="hd">
<h2>
<span>
Accessibility API
</span>
</h2>
</div>

<div class="intro tal">
<p>
At the top level, the first concept to understand is the platform Accessibility API, which is an integral part of each Operating System. This is MSAA/UIA/IAccessible2 on Windows, AT-SPI/IAccessible2 on Linux, the OS X Accessibility Protocol on Mac and iOS, and so on.
</p>
<p>
It may not be obvious, but these top level accessibility APIs have a direct relationship with web technology development, and are critical for the accessibility of interactive ARIA Widgets in particular.
</p>
<p>
For example, at the platform level in the Windows OS, there is a Checkbox control type. This is documented at<br />
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/system.windows.controls.checkbox(v=vs.110).aspx">http://msdn.microsoft.com/en-us/library/system.windows.controls.checkbox(v=vs.110).aspx</a>
</p>
<p>
When a control such as this, or of any other type, is rendered as part of the Graphical User Interface (GUI), the control and all of its public properties and states, is included in the Accessibility Tree.
</p>
<p>
The Accessibility Tree is a hierarchical construct of objects that include accessible names and descriptions, plus supporting states and properties, which Assistive Technologies can interface with to enhance accessibility.
</p>
<p>
Screen readers for example use the accessible Name of a Checkbox object to convey its name, the Role to convey the control type, the State to convey whether it is focused or checked, and so on every time a user interacts with this particular control.
</p>
<p>
There are software utilities that make it possible to traverse these Accessibility Tree objects, in order to observe the various properties and states as they change.
</p>
<p>
One such for Windows OS users is Active Accessibility Object Inspector:<br />
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/dd318521(VS.85).aspx">http://msdn.microsoft.com/en-us/library/dd318521(VS.85).aspx</a>
</p>
<p>
Another for OS X, is Accessibility Inspector:<br />
<a target="_blank" href="https://developer.apple.com/library/mac/documentation/Accessibility/Conceptual/AccessibilityMacOSX/OSXAXTesting/OSXAXTestingApps.html">https://developer.apple.com/library/mac/documentation/Accessibility/Conceptual/AccessibilityMacOSX/OSXAXTesting/OSXAXTestingApps.html</a>
</p>
<p>
Blind developers who use JAWS For Windows can utilize a JAWS script called BX (developed by Doug Lee):<br />
<a target="_blank" href="http://www.dlee.org/bx/jfw_bx15a.exe">http://www.dlee.org/bx/jfw_bx15a.exe</a><br />
Which allows access to the Accessibility Tree objects using the MSAA and UIA maps. Instructions for using BX is detailed at<br />
<a target="_blank" href="http://www.dlee.org/bx/bxman.htm">http://www.dlee.org/bx/bxman.htm</a>
</p>
</div>

<div class="hd">
<h3>
<span>
Times of Yore
</span>
</h3>
</div>

<div class="intro tal">
<p>
To put things into perspective, it is helpful to understand the foundations of the Accessibility Tree and ARIA.
</p>
<p>
Originally, the Accessibility API on native platforms leveraged the window tree hierarchy. The reason being, that Windows applications needed to be able to propagate mouse and keyboard events upward from an object to its ancestors. This allowed desktop applications to have containers that managed their children, such as Listboxes with child Option objects. The Accessibility API used this hierarchy to determine context, such as the number of child objects matching a specific Role.
</p>
<p>
As desktop applications became more complex, they started to utilize object trees, instead of relying solely on window handles as they had previously. Thus allowing applications to manage child objects more effectively, in order to process mouse and keyboard events within the context of the same structure. This was when the Accessibility API was bound to the platform object tree, which first occurred when Microsoft implemented OLE Accessibility in 1995; later to be renamed MSAA (Microsoft Active Accessibility). This object structure is now what is referred to as the Accessibility Tree.
</p>
<p>
When it was realized that the hierarchical DOM structure mirrored the Accessibility Tree structure, in order to propagate events upward to ancestors, it became clear that browsers could leverage the same technique using pertinent Roles and States to map specific control types and their children to the Accessibility API on the hosting platform, as long as the semantic hierarchy and parent/child Roles were correctly applied in the DOM. Browsers could then build an Accessibility Tree using these API mappings.
</p>
<p>
This has been a bumpy ride however, subject to the reverse engineering of each Accessibility API since the release of Dos in 1981, when Accessibility APIs went from looking at the Dos->framebuffer to sniffing GDI calls in Windows 3.1. This was broken with the switch to Windows 95, which was when the OLE Accessibility API was introduced to provide a series of backdoor processes that screen readers could interface with. Shortly after, to take advantage of marketing around the popularity of ActiveX at the time, Microsoft changed "OLE" to "Active", which is how Microsoft Active Accessibility (MSAA) was named. Later this API was extended and renamed as UI Automation (UIA).
</p>
<p>
The first attempt at mapping base-line platform concepts from the DOM to the more traditional Windows platform, was made by Richard Schwerdtfeger and T.V Raman while brainstorming in 2002, in order to devise a way of determining the nature of a DHTML widget without first requiring the execution of JavaScript. This is when ARIA DOM attributes were conceived. Since the purpose of ARIA was designed as a detection and mapping mechanism for Roles and States, it set the course for what we know as ARIA today. This is why the use of ARIA does not currently include any scripting behaviors when attributes are applied to the DOM; requiring that developers be familiar with these concepts in advance.
</p>
<p>
<i>
(Historical account provided by Richard Schwerdtfeger and T.V Raman)
</i>
</p>
</div>

<div class="hd">
<h3>
<span>
Standard Operating System Controls
</span>
</h3>
</div>

<div class="intro tal">
<p>
Going back to our Checkbox example, the following demonstration shows how specific web components are directly tied to the top level Accessibility API in the Operating System.
<i>
(Verified using Windows7)
</i>
</p>
<ol><li>
Through the Control Panel, open Internet Options.
</li><li>
On the General screen that opens, you will see a checkbox named "Delete browsing history on exit"
</li><li>
Using a utility such as Object Inspector or BX to observe the Accessibility Tree object, examine the object properties.
</li></ol>
<p>
You can see that the Role is that of "check box" (44), that the Name is that of "Delete browsing history on exit", and that the State when focused and checked is that of "FOCUSED CHECKED FOCUSABLE" (1048596).
</p>
</div>

<div class="hd">
<h3>
<span>
Standard Web Controls
</span>
</h3>
</div>

<div class="intro tal">
<ol><li>
Paste the following HTML markup into a text file, and save the new file into My Documents using the name "test.html".
<br /><br />
<code>
&lt;html&gt;&lt;body&gt;<br />
&lt;input type="checkbox" checked title="Delete browsing history on exit" /&gt;<br />
&lt;/body&gt;&lt;/html&gt;
</code>
<br /><br />
This is a standard HTML form field Checkbox control, as documented at<br />
<a target="_blank" href="http://www.w3.org/TR/html-markup/input.checkbox.html">http://www.w3.org/TR/html-markup/input.checkbox.html</a>
</li><li>
Now open the file test.html within Internet Explorer, and check the Accessibility Tree object for the Checkbox in the same manner as before.
</li></ol>
<p>
You can see that the Role is that of "check box" (44), that the Name is that of "Delete browsing history on exit", and that the State when focused and checked is that of "FOCUSED CHECKED FOCUSABLE" (1048596 in IE11). 
</p>
<p>
The Accessibility Tree object Role, Name, and State values on the web Checkbox match the software Checkbox control in the Operating System.
</p>
</div>

<div class="hd">
<h3>
<span>
Simulated Web Controls using ARIA
</span>
</h3>
</div>

<div class="intro tal">
<p>
Here is where we can see how important ARIA is, and what its impact is on the Accessibility Tree.
</p>
<p>
ARIA stands for Accessible Rich Internet Applications, and it provides a method for developers to manipulate the Accessibility Tree through the browser using specific attributes within the markup.
</p>
<p>
A more detailed introduction to ARIA is available at<br />
<a target="_blank" href="http://www.w3.org/WAI/intro/aria">http://www.w3.org/WAI/intro/aria</a>
</p>
<p>
This capability is extremely powerful, and allows developers to force a connection between custom web controls and their equivalent software component types on the Operating System.
</p>
<ol><li>
Paste the following HTML markup into the file "test.html".
<br /><br />
<code>
&lt;span tabindex="0" title="Delete browsing history on exit"<br />
class="checked" style="display:block;width:20px;height:20px;background-color:red;"&gt;&lt;/span&gt;
</code>
<br /><br />
This is a standard SPAN element, as documented at<br />
<a target="_blank" href="http://www.w3.org/TR/html-markup/span.html">http://www.w3.org/TR/html-markup/span.html</a>
</li><li>
Now open the file test.html within Internet Explorer, and check the Accessibility Tree object for the SPAN in the same manner as before.
</li></ol>
<p>
You can see that the Role is that of "grouping" (20), that the Name is that of "Delete browsing history on exit", and that the State when focused is that of "FOCUSED FOCUSABLE" (1048580 in IE11).
</p>
<p>
In essence, this is a standard SPAN element that has been made focusable using tabindex, and includes a Title attribute, but is nothing more in the Accessibility Tree. There is no mapping to a Checkbox control type with relevant State information on the Operating System.
</p>
<p>
To change the Role of this element and map it to the Operating System Checkbox control, the ARIA attributes role="checkbox" and aria-checked need to be added to the markup.
</p>
<ol><li>
Paste the following HTML markup into the file "test.html".
<br /><br />
<code>
&lt;span tabindex="0" role="checkbox" aria-checked="true" title="Delete browsing history on exit"<br />
class="checked" style="display:block;width:20px;height:20px;background-color:red;"&gt;&lt;/span&gt;
</code>
<br /><br />
This is strictly in accordance with the Roles Model spec for role=checkbox, at<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#checkbox">http://www.w3.org/TR/wai-aria/roles#checkbox</a>
</li><li>
Now open the file test.html within Internet Explorer, and check the Accessibility Tree object for the SPAN in the same manner as before.
</li></ol>
<p>
Now, you can see that the Role is that of "check box" (44), that the Name is that of "Delete browsing history on exit", and that the State when focused and checked is that of "FOCUSED CHECKED FOCUSABLE" (1048596 in IE11).
</p>
<p>
The simulated Checkbox control has now been mapped to its software equivalent on the Operating System, which makes it possible for Assistive Technologies like screen readers to convey it properly by accessing supporting states and properties such as the "check box" role, the current CHECKED state, and the accessible name.
</p>
<p id="8-15-2014-1" tabindex="-1">
Specific to UIA on Windows, all valid Role mappings are listed at:<br />
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/windows/apps/hh452705.aspx">http://msdn.microsoft.com/en-us/library/windows/apps/hh452705.aspx</a><br />
<i>
(Excerpt: "The table in this section shows how Accessible Rich Internet Applications (ARIA) roles map to Microsoft UI Automation control types and control patterns.")
</i><br />
And valid Properties:<br />
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/windows/apps/hh452708.aspx">http://msdn.microsoft.com/en-us/library/windows/apps/hh452708.aspx</a>
</p>
</div>

</div>

<div role="region" aria-label="ARIA, Important Details">

<div class="hd">
<h2>
<span>
ARIA, Important Details
</span>
</h2>
</div>

<div class="intro tal">
<p>
When ARIA is implemented correctly, you can literally change the nature of a custom web component in order to maximize accessibility for Assistive Technology users. 
</p>
<p>
When used incorrectly however, you can instead break the Accessibility API mapping on the Operating System and cause the same custom web components to become virtually unusable by Assistive Technology users.
</p>
<p>
As a result, extreme care must always be applied when implementing interactive ARIA Widgets.
</p>
<p>
There are three primary documents that dictate how ARIA works and should be applied by developers.
</p>
</div>

<div class="hd">
<h3>
<span>
User Agent Implementation Guide
</span>
</h3>
</div>

<div class="intro tal">
<p id="8-18-2014-1" tabindex="-1">
The first document is the UAIG (User Agent Implementation Guide), an introduction to which is available at<br />
<a target="_blank" href="http://www.w3.org/WAI/PF/aria-implementation/#intro">http://www.w3.org/WAI/PF/aria-implementation/#intro</a>
</p>
<p>
The UAIG provides specific guidance for browser and Assistive Technology vendors so that ARIA support can be equally supported by both.
</p>
<p>
For ARIA technologies to work reliably, both browsers and Assistive Technologies must meet in the middle, so that browsers can properly update the Accessibility Tree as specified, and Assistive Technologies can use the Accessibility Tree to provide accurate functionality for end users.
</p>
<p>
An ARIA Menu is a simple example of why this collaboration is important.
</p>
<p>
The Windows platform UI equivalent for this is documented at<br />
<a target="_blank" href="http://msdn.microsoft.com/en-us/library/system.windows.controls.contextmenu.aspx">http://msdn.microsoft.com/en-us/library/system.windows.controls.contextmenu.aspx</a>
</p>
<p>
When an ARIA Menu is constructed strictly according to spec, It causes specific events to fire in the browser, which Assistive Technologies then use to ensure accessibility by customizing feedback and behavior.
</p>
<p>
This process is documented in the UAIG, at<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria-implementation/#mapping_events_menus">http://www.w3.org/TR/wai-aria-implementation/#mapping_events_menus</a>
</p>
<p>
It's important to note that, in order for an ARIA Menu to be programmed strictly according to spec, it must meet all of the following requirements:
</p>
<ol><li>
If styled vertically, the menu container must include
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menu">role="menu"</a>.<br />
If styled horizontally, the menu container must include
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menubar">role="menubar"</a>.
</li><li>
All selectable children within the menu must include one of the following Roles:<br />
<ul><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menuitem">role="menuitem"</a>
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menuitemcheckbox">role="menuitemcheckbox"</a>
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menuitemradio">role="menuitemradio"</a>
</li></ul>
</li><li>
Through scripting:<br />
<ul><li>
Programmatic focus must only be set to elements that include a Role of menu, menubar, menuitem, menuitemcheckbox, or menuitemradio.
</li><li>
When a menu or submenu opens, focus must be set to the new menu.
</li><li>
A menu should have only one tab stop.
</li><li>
The arrow keys should traverse logically through each menu item node as expected, or open or close submenus when applicable.
</li></ul>
</li><li>
If a menu item node opens a submenu (another ARIA Menu construct), the focusable element node that includes role="menuitem" must also include
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-haspopup">aria-haspopup="true"</a>.
</li><li>
If an external keyboard accessible triggering element opens a menu, it too must include the attribute aria-haspopup="true".
</li><li>
If programmatic focus is set to the element node that includes role="menu" or role="menubar", the attribute
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-activedescendant">aria-activedescendant</a>
must be used to point to the currently selected menu item node that includes either role="menuitem", role="menuitemcheckbox", or role="menuitemradio".
</li></ol>
<p>
Live examples:
</p>
<ul><li>
Vertical:
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Menus/Vertical%20(Internal%20Content)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Menus/Vertical%20(Internal%20Content)/demo.htm</a>
</li><li>
Horizontal:
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Menus/Horizontal%20(Internal%20Content)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Menus/Horizontal%20(Internal%20Content)/demo.htm</a>
</li></ul>
<ol><li>
Open either one of the above pages using IE11.
</li><li>
Right-click anywhere within the static content on the page to open a regular context menu.
</li></ol>
<p>
Using a utility such as Object Inspector or BX to observe the Accessibility Tree object, you can see that the parent menu Role is that of "popup menu" (11), that the child menu options have a Role of "menu item" (12), and that the State of the highlighted "menu item" Accessibility Tree object includes FOCUSED.
</p>
<p>
You can get the same result by right-clicking the Desktop to open a popup menu there, and the Accessibility Tree information will be the same.
</p>
<p>
Now, activate the "Options (Vertical Dropdown)" button to open the ARIA Menu on the test page, and examine the Accessibility Tree.
</p>
<p>
You will see that the Accessibility Tree objects exactly match, even down to the State including FOCUSED on the highlighted "menu item" Accessibility Tree object.
</p>
<p>
This is why proper scripting to ensure programmatic focus is so important when building ARIA Widgets, otherwise the correct events will not fire or be recognized by Assistive Technologies.
</p>
<p>
This is also why you should never improperly mix ARIA Widget markup with active elements that contradict the Operating System equivalent for that control type, nor allow focus to be set to elements that are not part of the intended Widget construct.
</p>
<p>
Meaning, focus should only be set to elements that include valid Roles for that Widget type.
</p>
<p>
Otherwise, the element that has focus will not be the same one that includes the correct Accessibility Tree object information for Assistive Technologies to interface with.
</p>
<p>
For example, the following is an invalid use of ARIA Menu markup:
</p>
<p>
<code>
&lt;ul role="menu"&gt;<br />
&lt;li role="menuitem"&gt;<br />
&lt;form&gt;<br />
&lt;input type="text" title="Email" /&gt;<br />
&lt;input type="submit" /&gt;<br />
&lt;/form&gt;<br />
&lt;/li&gt;<br />
&lt;li role="menuitem"&gt;<br />
&lt;a href="somewhereelse.html"&gt;<br />
Help...<br />
&lt;/a&gt;<br />
&lt;/li&gt;<br />
&lt;li role="menuitem"&gt;<br />
&lt;button&gt;<br />
Settings...<br />
&lt;/button&gt;<br />
&lt;/li&gt;<br />
&lt;/ul&gt;
</code>
</p>
<p>
This is invalid markup, because there is no software control equivalent to map such a construct to in the Operating System, and the elements that receive focus don't include the relevant Accessibility Tree object information to match a Menu construct.
</p>
<p>
Conceptually, this would be equivalent to right-clicking a web page, and within the context menu that pops up, finding a form text field and submit button, plus separate links and buttons within each menu item listed there.
</p>
<p>
Similarly, the following markup is equally invalid:
</p>
<p>
<code>
&lt;div role="textbox"&gt;<br />
&lt;label for="name"&gt; First name:&lt;/label&gt;<br />
&lt;input type="text" id="name" name="first-name" /&gt;<br />
&lt;/div&gt;
</code>
</p>
<p>
At the Accessibility Tree level, the above markup is equivalent to the following:
</p>
<p>
<code>
&lt;textarea&gt;<br />
&lt;label for="name"&gt; First name:&lt;/label&gt;<br />
&lt;input type="text" id="name" name="first-name" /&gt;<br />
&lt;/textarea&gt;
</code>
</p>
<p>
It doesn't make sense to Assistive Technologies, and breaks the Accessibility API mappings in the Accessibility Tree.
</p>
<p>
The manner in which browsers and Assistive Technologies process all supported Roles, is documented in the UAIG Role Mappings section at<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria-implementation/#mapping_role">http://www.w3.org/TR/wai-aria-implementation/#mapping_role</a>
</p>
<p>
All developers implementing ARIA should be familiar with this section as well.
</p>
</div>

<div class="hd">
<h3>
<span>
ARIA Roles Model
</span>
</h3>
</div>

<div class="intro tal">
<p>
The second document is the ARIA Roles Model, available at<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles">http://www.w3.org/TR/wai-aria/roles</a>
</p>
<p>
The ARIA Roles Model defines the markup requirements for synchronizing front-end coding with the back-end behaviors documented in the User Agent Implementation Guide for browsers and Assistive Technologies.
</p>
<p>
All developers wishing to implement ARIA must read all of this document, and keep on doing so until it finally makes sense.
</p>
<p>
Otherwise, misinterpretations and incorrect ARIA implementations will continue to be built across the web as the result of misunderstandings.
</p>
<p>
For example, the following scenarios are the most common pitfalls that developers fall into when attempting to implement ARIA Widgets:
</p>
<ul><li>
Developers add ARIA attributes, but fail to add keyboard support and requisite scripting behaviors that match the Widget type.
</li><li>
Developers add focus movement and scripting behaviors that don't coincide with the elements that include valid ARIA Roles for that Widget type.
</li><li>
Developers add some ARIA Roles for a specific Widget type, but fail to add others that are required to complete the Widget type.
</li><li>
Developers add ARIA Roles, but fail to add required state or property attributes for that Widget type.
</li><li>
Developers don't understand how ARIA usage is supposed to effect functionality within Assistive Technologies.
</li></ul>
<p>
There is only one way to truly understand something, and that is to immerse yourself within it.
</p>
</div>

<div class="hd">
<h3>
<span>
ARIA Supported States and Properties
</span>
</h3>
</div>

<div class="intro tal">
<p>
The third document is the ARIA Supported States and Properties, available at<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties">http://www.w3.org/TR/wai-aria/states_and_properties</a>
</p>
<p>
The Supported States and Properties document specifies all available states and properties that are valid upon specific Roles.
</p>
<p>
For example, the aria-pressed attribute, documented at<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-pressed">http://www.w3.org/TR/wai-aria/states_and_properties#aria-pressed</a><br />
Is only valid upon elements that have a Role of "button", and is not valid anywhere else.
</p>
<p>
Live demo:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Toggles,%20Checkboxes,%20Links,%20and%20Buttons/ARIA%20Toggle%20Buttons/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Toggles,%20Checkboxes,%20Links,%20and%20Buttons/ARIA%20Toggle%20Buttons/demo.htm</a>
</p>
<p>
Examining the Accessibility Tree objects on Windows will show that each toggle in the above demo is mapped to a Role of "push button" (43), and that the State is "FOCUSED FOCUSABLE" when aria-pressed="false", or "FOCUSED PRESSED FOCUSABLE" when aria-pressed="true".
</p>
<p>
All developers wishing to implement ARIA must also be familiar with the Supported States and Properties document, in order to understand which states and properties are valid for specific element and Role types.
</p>
</div>

<div class="hd">
<h3>
<span>
ARIA and CSS
</span>
</h3>
</div>

<div class="intro tal">
<p>
Often CSS is used to apply uniform styling across browsers, using markup that doesn't reflect the control type that is represented.
</p>
<p>
A basic example of this is styling a link to appear visually as a toggle button.
</p>
<p>
The problem however, is that CSS has no effect on the Accessibility Tree, causing a disparity to occur between what is visually displayed and what is experienced by the Assistive Technology user.
</p>
<p>
This can be addressed by binding CSS with ARIA Role and State attributes, which speeds processing for dynamic rendering, automatically matches the correct ARIA Roles and States with equivalent control styling, and provides a visual mechanism for verifying the correct usage of ARIA at a glance.
</p>
<p>
Speed is improved by reducing the number of DOM changes that must occur in order to synchronize the setting of Accessibility Tree Roles and States with matching styles.
</p>
<p>
For example, as Accessibility Tree Roles and States are set using ARIA attributes, there is no need to ensure that relevant class names are updated in the DOM at the same time, because this is handled automatically as part of the CSS binding.
</p>
<p>
This technique also ensures that the correct ARIA Role always matches the visually displayed UI control type.
</p>
<p>
Similarly, this technique can be used to verify that ARIA Roles and supporting attributes are implemented correctly, by providing a visual representation for the control type only when they match; thus allowing developers to see at a glance when controls are not marked up properly.
</p>
<p>
The following code is a simple demonstration of this.
</p>
<p>
<code>
&lt;html&gt;&lt;head&gt;<br />
&lt;style type="text/css"&gt;<br />
<br />
a[role="button"][aria-pressed="true"][href] {<br />
/* Add styling for a pressed toggle button. */<br />
color: purple; background-color: yellow;<br />
}<br />
<br />
a[role="button"][aria-pressed="false"][href] {<br />
/* Add styling for a toggle button that is not pressed. */<br />
color: yellow; background-color: purple;<br />
}<br />
<br />
span[role="button"][tabindex] {<br />
/* Add styling for a standard button. */<br />
color: yellow; background-color: black;<br />
}<br />
<br />
&lt;/style&gt;<br />
&lt;/head&gt;&lt;body&gt;<br />
<br />
&lt;a role="button" aria-pressed="true" href="#"&gt;<br />
Spell Check<br />
&lt;/a&gt;<br />
<br />
&lt;span role="button" tabindex="0"&gt;<br />
Login<br />
&lt;/span&gt;<br />
<br />
&lt;/body&gt;&lt;/html&gt;
</code>
</p>
<p>
Notice how the CSS styling declaration for each A tag includes three attributes, role="button", aria-pressed, and href.
</p>
<p>
This enforces all three of the following requirements before the styling will be rendered visually.
</p>
<ol><li>
The Role of "button" must be present on the A element.
</li><li>
The State of aria-pressed must be set to either "true" or "false" on the A element.
</li><li>
The href attribute must be included within the A element to ensure keyboard accessibility.
</li></ol>
<p>
The same is true for the SPAN CSS declaration, which includes two attributes, role="button" and tabindex. Thus enforcing the following:
</p>
<ol><li>
The Role of "button" must be present on the SPAN element.
</li><li>
The tabindex attribute must be included within the SPAN element to ensure keyboard accessibility.
</li></ol>
<p>
This makes it possible to dynamically update one attribute, such as changing aria-pressed from "true" to "false", and the accompanying style will automatically be applied to convey this visually.
</p>
<p>
Also, if required attributes are missing as the result of developer error, the visual styling will not be applied, making it obvious at a glance which controls are not programmed correctly.
</p>
</div>

<div class="hd">
<h3>
<span id="8-1-2014-1" tabindex="-1">
ARIA Drag and Drop
</span>
</h3>
</div>

<div class="intro tal">
<p>
One of the most confusing interactive widget types to implement, is ARIA drag and drop.
</p>
<p>
The relevant ARIA attributes for which, are referenced at<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#attrs_dragdrop">http://www.w3.org/TR/wai-aria/states_and_properties#attrs_dragdrop</a><br />
Specifically:
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-grabbed">aria-grabbed</a>
and
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-dropeffect">aria-dropeffect</a>
</p>
<p>
The first thing to note, is that the attributes aria-grabbed and aria-dropeffect have no functional effect on the draggability of a component. This must be programmed in advance using JavaScript and CSS to handle mouse and keyboard interaction. The drag and drop ARIA attributes simply convey these relevant behaviors to Assistive Technologies.
</p>
<p>
This means that, drag and drop will not be made accessible just by adding these attributes.
</p>
<p>
There are many ways that drag and drop can be implemented, including movable components for dynamic UIs, drag and drop into associated target zones, flexible widgets, and so on.
</p>
<p>
I'll cover the most common implementations here, defined as:
</p>
<ul><li>
Unassociated: Where components are draggable with no associated drop zone.
</li><li>
Associated: Where components require being dragged to one or more drop zones.
</li><li>
Internal: Where drag and drop is available on the children of a parent control type.
</li></ul>
</div>

<div class="hd">
<h4>
<span>
Unassociated
</span>
</h4>
</div>

<div class="intro tal">
<p>
Unassociated drag and drop implementations are the simplest to implement, and are typically seen on dynamic UIs where page components can be dragged around to rearrange the visual layout.
</p>
<p>
The draggable region can be made keyboard accessible by adding tabindex="0" to the draggable container element, or to the drag handle element. Scripting is then used to control movement when the arrow keys are pressed.
</p>
<p>
Additionally, aria-grabbed="false" should be added to either the draggable container element, or to the drag handle element, whichever is designed to be focusable. Then, when the item is ready to be dragged, whether this is by setting focus to the draggable container element or to the drag handle element, then aria-grabbed should be programmatically set to "true". When dragging is no longer available, triggered using onBlur for example, then aria-grabbed should be programmatically set back to "false".
</p>
<p>
If the drag and drop implementation is meant to be progressively enhanced, so it is usable across both desktop and mobile devices, then the touch event model should be taken into account as well.
</p>
<p>
The following resource describes all relevant touch events as part of a compatibility index:<br />
<a target="_blank" href="http://patrickhlauke.github.io/touch/tests/results/">http://patrickhlauke.github.io/touch/tests/results/</a><br />
Which is important to understand when screen readers are involved.
</p>
<p>
This covers the basics, but there is still no textual equivalent for screen reader users, which will result in a dead tab stop when focus is set to an element without a valid Role.
</p>
<p>
If a drag handle element is used to initiate draggability, then a Button Role (including an explicit label) is useful to convey this information.
</p>
<p>
Example syntax:
</p>
<p>
<code>
&lt;div role="region" aria-label="Component Name"&gt;<br />
&lt;div class="dragHandle" tabindex="0" role="button" aria-label="Move Component Name" aria-grabbed="false"&gt;&lt;/div&gt;<br />
&lt;div&gt;<br />
Content...<br />
&lt;/div&gt;<br />
&lt;/div&gt;
</code>
</p>
<p>
If a draggable container element is used instead, then the following syntax can be used:
</p>
<p>
<code>
&lt;div class="draggable" tabindex="0" role="button" aria-labelledby="contentId" aria-grabbed="false"&gt;<br />
&lt;div id="contentId"&gt;<br />
Movable content...<br />
&lt;/div&gt;<br />
&lt;/div&gt;
</code>
</p>
<p>
Or
</p>
<p>
<code>
&lt;div class="draggable" tabindex="0" role="button" aria-label="Move Component Name" aria-grabbed="false"&gt;<br />
&lt;div&gt;<br />
&lt;img alt="" src="path/file.jpg" /&gt;<br />
&lt;/div&gt;<br />
&lt;/div&gt;
</code>
</p>
<p>
Or
</p>
<p>
<code>
&lt;img class="draggable" tabindex="0" role="button" aria-label="Move Component Name" aria-grabbed="false" src="path/file.jpg" /&gt;
</code>
</p>
<p>
Obviously, the draggable container element technique should not include any other active elements. Otherwise it will appear that there are nested active elements in the Accessibility Tree, which won't be conveyed properly by Assistive Technologies.
</p>
<p>
There are two other reasons why it is not advisable to set focus to a container element that includes aria-grabbed when the container includes other active elements.
</p>
<ol><li>
All static content and active elements within the container will be conveyed to screen reader users as being grabbable or grabbed, even if they are not.
<i>
(Verified using JAWS15 in IE11 and FF)
</i>
</li><li>
There is no way to reliably convey the draggability of a container on touch screen devices when its content includes other active elements that perform different actions.
<i>
(This is true for both sighted and non-sighted users.)
</i>
</li></ol>
<p>
To ensure the most reliable results, all draggable components that include other active elements, should also include a drag handle to indicate this functionality visually, as well as for sighted and non-sighted keyboard users as shown in the first example.
</p>
<p>
Whichever technique is used, a visual indication of this functionality must also be displayed when the draggable container element or drag handle element receives focus, in order to convey to sighted keyboard only users that the component is draggable, as well as the keyboard mechanism for doing this.
</p>
<p>
One way to accomplish this is to display a tooltip onFocus to convey this functionality. This tooltip can then be associated with the triggering element using
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-describedby">aria-describedby</a>
so that it appears within the Description property of the Accessibility Tree object for Assistive Technologies to utilize.
</p>
<p>
Example syntax:
</p>
<p>
<code>
&lt;div role="region" aria-label="Component Name"&gt;<br />
&lt;div class="dragHandle" tabindex="0" role="button" aria-label="Move Component Name" aria-grabbed="false" aria-describedby="tooltipId"&gt;&lt;/div&gt;<br />
&lt;div style="display:none;" id="tooltipId" role="tooltip"&gt; Press the arrow keys to move Component Name &lt;/div&gt;<br />
&lt;div&gt;<br />
Content...<br />
&lt;/div&gt;<br />
&lt;/div&gt;
</code>
</p>
<p>
If you paste the above markup into a test page, and examine the Accessibility Tree object for the focusable drag handle element, you will see that its Description property now states "Press the arrow keys to move Component Name".
<i>
(Verified using IE11 and FF on Win7)
</i>
</p>
<p>
By associating the tooltip text with the Accessibility Tree object, it is then possible for all Assistive Technologies to utilize the Description property as part of an interoperable Accessibility API feature.
</p>
<p>
<i>
(This can be programmatically disabled for touch screen devices where keyboard functionality is not equivalent to desktop usage, by adding gesture event listeners within the UI to determine the correct modality.)
</i>
</p>
</div>

<div class="hd">
<h4>
<span>
Associated
</span>
</h4>
</div>

<div class="intro tal">
<p>
Associated drag and drop components require that the dragged component be dropped within the region of a drop zone.
</p>
<p>
Regarding the accessibility of the draggable component, all of the same issues and solutions apply as previously described for Unassociated drag and drop components.
</p>
<p>
There are some important differences however.
</p>
<p>
First, the primary issues:
</p>
<ul><li>
It is impossible for non-sighted users to accurately gage where drop zones are located on a page, which is true across both desktop and mobile devices.
</li><li>
It is overly difficult and time consuming for sighted keyboard only users to manually position a draggable component over a specific drop zone when using the arrow keys as previously described.
</li><li>
The addition of aria-dropeffect on the drop zone element will help identify a droppable region for Assistive Technologies, but it will not actually make drag and drop accessible for screen reader and keyboard only users.
</li></ul>
<p>
To solve all of these issues, a different approach is required.
</p>
<p>
When a draggable component has only one associated drop zone, the simplest and most effective technique, is to provide an actionable element that triggers the drag and drop action automatically with one key press.
</p>
<p>
An offscreen Link or Button can be used for this purpose, which appears visually onFocus, and is positioned offscreen onBlur for sighted keyboard only users. This acts as both an informative tooltip and a triggering element at the same time.
</p>
<p>
For this technique to work properly, offscreen positioning must be used instead of the CSS properties display:none or visibility:hidden, in order to ensure accessibility for screen readers that support virtual offscreen models such as JAWS and NVDA.
</p>
<p>
The label for such a Link or Button requires that all of the following information be conveyed:
</p>
<ul><li>
The action to be performed, such as "Move"
</li><li>
The name of the component it applies to, such as "Component Name"
</li><li>
The drop zone name to which the action applies, such as "Trash"
</li></ul>
<p>
Example: "Move Component Name to Trash"
</p>
<p>
When activated from the keyboard, the drag and drop action is automatically performed, and the desired component is processed in the same manner as though it were dragged and dropped using the mouse.
</p>
<p>
An example of this can be seen at<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/Drag%20and%20Drop/demo.htm">http://whatsock.com/tsg/Coding%20Arena/Drag%20and%20Drop/demo.htm</a>
</p>
<p>
Which supports all of the following interactions:
</p>
<ul><li>
Keyboard navigation using Tab or Shift+Tab.
</li><li>
Up and Down arrow navigation using the virtual offscreen model, as seen using JAWS and NVDA.
</li><li>
Link navigation on touch screen devices such as iOS.<br />
<i>
(For example, swipe left or right with one finger to select a Link using VoiceOver, then double tap to initiate drag and drop.)
</i>
</li></ul>
<p>
In the case of a draggable component that includes embedded active elements, where a drag handle element is present, the same offscreen Link or Button technique can be used.
</p>
<p>
It's important to note that, in both cases, where a draggable container element or a drag handle element is used, neither the container element nor the drag handle element should receive focus. Since keyboard and screen reader accessibility is managed using an offscreen Link or Button, only the relevant Link or Button should receive focus. This will have no negative effect for sighted mouse users, who will never encounter the offscreen Link or Button.
</p>
<p>
When a draggable component is associated with multiple drop zones, the offscreen Link or Button technique can be used here as well.
</p>
<p>
The difference being, that the triggering element should open a Menu, where the desired drop zone can then be activated to initiate drag and drop from the keyboard.
</p>
</div>

<div class="hd">
<h4>
<span>
Internal
</span>
</h4>
</div>

<div class="intro tal">
<p>
Internal drag and drop components consist of the draggable children of a parent control type.
</p>
<p>
Such implementations vary, and are dependent on the parent control type that is implemented. For example, this may be used to rearrange Tabs in a Tablist, or to reorder Rows in a Grid, or to move Options from one Listbox to another, and so on.
</p>
<p>
As a result, keyboard support will vary as well. Tabs may use Control+Left/Right to drag one Tab left or right, a Grid may use Control+Up/Down to move a Row up or down, Listboxes may use Control+Right to move Options from the left Listbox to the right (or the reverse), etc. Assigned key commands depend on the layout of the UI and what the intended functionality is for the Widget type.
</p>
<p>
In all of these cases, aria-grabbed can be used to identify which focusable child is or is not grabbed, and aria-dropeffect can be used to identify relevant drop zones and their actions.
</p>
<p>
Another important note to be aware of, the attributes aria-grabbed and aria-dropeffect don't require the accompaniment of mouse draggability at the same time to be utilized effectively.
</p>
<p>
An example of this can be seen at<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Listboxes/Sortable/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Listboxes/Sortable/demo.htm</a><br />
Which is a sortable Listbox Widget.
</p>
<p>
Keyboard users can:
</p>
<ol><li>
Press the Up and Down arrow keys to navigate within the Listbox.
</li><li>
Press the Spacebar to grab the selected Option.
</li><li>
Press the Up or Down arrow keys to navigate to another location in the Listbox.
</li><li>
Press the Spacebar again to drop the grabbed Option into the new location.
</li></ol>
<p>
Sighted mouse users can:
</p>
<ol><li>
Click an Option to grab it.
</li><li>
Click another Option to drop it in that location.
</li></ol>
<p>
The attributes aria-grabbed and aria-dropeffect are dynamically updated on each Listbox Option to reflect all of these behaviors as they occur.
</p>
</div>

</div>

<div role="region" aria-label="ARIA Categories">

<div class="hd">
<h2>
<span>
ARIA Categories
</span>
</h2>
</div>

<div class="intro tal">
<p>
Typically, ARIA Role usage fits into one of five broad categories, Landmarks and Regions, Interactive Widgets, Compound Components, Corner Cases, or Live Regions.
</p>
</div>

<div class="hd">
<h3>
<span>
Landmarks and Regions
</span>
</h3>
</div>

<div class="intro tal">
<p>
Landmarks and Regions are amongst the easiest of ARIA Roles to implement, because they are content grouping mechanisms that aid navigation for Assistive Technology users.
</p>
<p>
As such, they don't require any keyboard support, nor scripting behaviors to function properly.
</p>
<p>
All Landmark Roles are defined at<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#landmark_roles">http://www.w3.org/TR/wai-aria/roles#landmark_roles</a>
</p>
</div>

<div class="hd">
<h4>
<span>
Application Role
</span>
</h4>
</div>

<div class="intro tal">
<p>
There are important details that you need to be aware of regarding the use of role="application":<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#application">http://www.w3.org/TR/wai-aria/roles#application</a>
</p>
<p>
First, the terminology is important to understand.
</p>
<p>
Many developers refer to interactive web technologies as applications, because they are dynamic, and often styled to resemble software user interfaces.
</p>
<p>
The logical assumption then, is to add role="application" to every such perceived 'web application'.
</p>
<p>
This is an incorrect assumption however, and often causes more harm than good when applied without understanding the Application Role in advance.
</p>
<p>
The purpose of role="application" is not simply to define a particular web technology as an application, but rather, to instruct an Assistive Technology to pass keystrokes through to the control that currently has focus. The region where this is applied dictates where this behavior occurs, and defines the area as an Application Landmark for navigability.
</p>
<p>
This behavior is valuable when simulated controls require the use of specific keystrokes to function properly, and it becomes necessary to override the default keystroke interception that is done by Assistive Technologies as part of standard interaction.
</p>
<p>
For example, JAWS and NVDA screen reader users can press the Up and Down arrows to navigate by line, Control+Up/Down to navigate by paragraph, 'h' to navigate by heading, and so on within the Virtual Buffer without passing any of these keys to the web page.
</p>
<p>
In most cases, this type of interaction is exactly what the user expects and wants. 
</p>
<p>
There are occasions though, when specific control types require the use of these intercepted keystrokes in order to function properly for both screen reader and keyboard only users. This is when role="application" is useful.
</p>
<p>
An example of this can be seen at:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Date%20Pickers/ARIA%20Date%20Picker%20(Basic)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Date%20Pickers/ARIA%20Date%20Picker%20(Basic)/demo.htm</a><br />
Which is an ARIA enhanced date picker.
</p>
<p>
When the date picker opens and focus is set to the current date, the use of role="application" forces JAWS and NVDA into Applications Mode, allowing the arrow keys to be used to navigate the calendar in a grid pattern, which would not occur without the presence of role="application".
</p>
<p>
Another misconception is that all form fields and interactive ARIA Widgets need to be surrounded by role="application" to make Assistive Technologies pass keystrokes to them.
</p>
<p>
This is incorrect, and there are two reasons why this should not be done.
</p>
<ol><li>
The use of role="application" causes NVDA to render the entire Application region on one line in the Virtual Buffer when in Browse Mode, making it impossible to discover the content without having to enter each Application region manually by pressing Enter on it to see what it contains. This also prevents NVDA users from using quick navigation keystrokes such as 'f' to jump between form fields, because all form fields included within an Application region are undetectable while focus is outside the region.
</li><li>
All form fields and interactive ARIA Widget types already support these behaviors without needing role="application".
</li></ol>
<p>
When role="application" is used, there is one Role that reverses Application Mode behavior when applied within the same region; this is role="document":<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#document">http://www.w3.org/TR/wai-aria/roles#document</a>
</p>
<p>
Similar to role="application", role="document" is often misunderstood. For example, it does not represent a literary document or the entire document structure of a web page as its name suggests.
</p>
<p>
The Document Role simply defines a container within an Application Landmark that should not enforce a particular mode of navigation, thus overriding role="application" and allowing an Assistive Technology user to navigate the content of that Document region in the same manner as a standard web page.
</p>
<p>
If there is no need to enforce a particular keyboard interaction model for a specific region on a page, then role="application" should not be used.
</p>
<p>
If role="application" is used on a particular region however, then all relevant interactive controls must be in the tab order and must be properly labelled, because Applications Mode enforces that only active elements are navigable; unless role="document" is used to override this behavior.
</p>
<p>
Historically this behavior was most noticeable using screen readers like JAWS and NVDA, where the textual content could not be accessed because it wasn't explicitly tied to an active element in the tab order.
</p>
<p>
In recent versions of JAWS and NVDA however, overrides have been added so that Applications Mode can be forcibly aborted, providing a mechanism for screen reader users to access textual information that may not have been correctly associated with active elements.
</p>
<p>
Nevertheless, it is still advisable to only use role="application" when you have a specific need to process keystrokes that are generally intercepted by Assistive Technologies.
</p>
</div>

<div class="hd">
<h4>
<span>
Region Role
</span>
</h4>
</div>

<div class="intro tal">
<p>
Another Role that is not listed as a Landmark, but is just as important for this purpose, is role="region":<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#region">http://www.w3.org/TR/wai-aria/roles#region</a>
</p>
<p>
The Region Role is helpful for grouping associated content on a page.
</p>
<p>
Though all Landmark Roles can optionally be explicitly labeled, the use of role="region" requires an explicit label to identify its purpose for Assistive Technologies.
</p>
<p>
This is achieved by including either aria-label or aria-labelledby on the same container element that includes role="region".
</p>
<p>
Example syntax:
</p>
<p>
<code>
&lt;div role="region" aria-label="Unique Name One" &gt;<br />
...<br />
&lt;/div&gt;
</code>
</p>
<p>
Or
</p>
<p>
<code>
&lt;div role="region" aria-labelledby="uniqueID" &gt;<br />
&lt;h2 id="uniqueID" &gt; Unique Name Two &lt;/h2&gt;<br />
...<br />
&lt;/div&gt;
</code>
</p>
<p>
<i>
(If a Region begins with a heading, aria-labelledby should be used to reference the heading as its Region label whenever possible.)
</i>
</p>
<p>
Since a named Region can represent any type of content, it can be applied anywhere.
</p>
<p>
A simple example can be seen at<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20and%20Non-ARIA%20Accordions/ARIA%20Accordion%20(Internal%20Content)/demo2.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20and%20Non-ARIA%20Accordions/ARIA%20Accordion%20(Internal%20Content)/demo2.htm</a><br />
Where each accordion section is represented as a named Region using aria-labelledby to reference the triggering element.
</p>
<p>
Similarly, all of the primary navigation sections on this page are contained within named Regions.
</p>
<p>
This allows Assistive Technologies to utilize Region navigation commands to jump between each named Region, or to identify the beginning and ending boundaries of a specific Region.
</p>
<p>
For example, if using JAWS15 in Internet Explorer or Firefox, you can press R or Shift+R to jump forward or backward between each Region, or press Insert+Control+R to show a list of named Regions and Landmarks on the page; thus simplifying navigation from any location.
</p>
</div>

<div class="hd">
<h5>
<span id="7-24-2014-1" tabindex="-1">
Scrollable Divs
</span>
</h5>
</div>

<div class="intro tal">
<p>
Scrollable Divs are often used to display variable content using minimal screen real estate, so that users can scroll through the offscreen content as desired without moving the viewport.
</p>
<p>
This is achieved by setting the CSS property overflow:auto on a Div, in addition to a fixed height and width.
</p>
<p>
By adding tabindex="0" to the Scrollable Div, the region magically becomes accessible to keyboard only users, because the browser automatically handles the scrolling effect when the arrow keys are pressed.
</p>
<p>
Since the Div has no explicit Role mapping in the Accessibility Tree however, screen readers see this as a dead tab stop that means nothing.
</p>
<p>
This is easily corrected though, by adding role="region plus an explicit label to the Scrollable Div.
</p>
<p>
Example syntax:
</p>
<p>
<code>
&lt;div tabindex="0" class="scrollable" role="region" aria-label="Message Log"&gt;<br />
&lt;div&gt;<br />
Scrollable content.<br />
&lt;/div&gt;<br />
&lt;/div&gt;
</code>
</p>
<p>
Or
</p>
<p>
<code>
&lt;div tabindex="0" class="scrollable" role="region" aria-labelledby="title-id"&gt;<br />
&lt;div id="title-id"&gt;<br />
Title Text<br />
&lt;/div&gt;<br />
&lt;div&gt;<br />
Scrollable content.<br />
&lt;/div&gt;<br />
&lt;/div&gt;
</code>
</p>
<p>
Now, when screen reader users encounter the Scrollable Div in the tab order, the region label will be announced and make it clear that this is an intentional UI control.
</p>
</div>

<div class="hd">
<h3>
<span>
Interactive Widgets
</span>
</h3>
</div>

<div class="intro tal">
<p>
Interactive Widget Roles, are all those that specifically map to platform UI equivalents in the Accessibility API.
</p>
<p>
These include all of the following primary Widget Roles:
</p>
<ul><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#button">
button
</a>
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#checkbox">
checkbox
</a>
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#combobox">
combobox
</a>
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#grid">
grid
</a>
(including children with relevant Roles:
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#rowgroup">rowgroup</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#row">row</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#rowheader">rowheader</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#columnheader">columnheader</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#gridcell">gridcell</a>)
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#link">
link
</a>
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#listbox">
listbox
</a>
(including children with relevant Roles:
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#option">option</a>)
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menu">
menu
</a>
(including children with relevant Roles:
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menuitem">menuitem</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menuitemcheckbox">menuitemcheckbox</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menuitemradio">menuitemradio</a>)
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menubar">
menubar
</a>
(including children with relevant Roles:
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menuitem">menuitem</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menuitemcheckbox">menuitemcheckbox</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#menuitemradio">menuitemradio</a>)
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#radio">
radio
</a>
(including ancestor with the relevant Role:
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#radiogroup">radiogroup</a>)
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#scrollbar">
scrollbar
</a>
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#slider">
slider
</a>
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#spinbutton">
spinbutton
</a>
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#tablist">
tablist
</a>
(including children with relevant Roles:
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#tab">tab</a>)
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#textbox">
textbox
</a>
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#tree">
tree
</a>
(including children with relevant Roles:
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#group">group</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#treeitem">treeitem</a>)
</li><li>
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#treegrid">
treegrid
</a>
(including children with relevant Roles:
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#rowgroup">rowgroup</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#row">row</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#rowheader">rowheader</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#columnheader">columnheader</a>,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#gridcell">gridcell</a>)
</li></ul>
<p>
All of the above Roles that specify "including children with relevant Roles", must manage programmatic focus by either setting focus to its primary container Role, or to one of its selectable child Roles. If focus is set to the primary container Role,
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-activedescendant">aria-activedescendant</a>
<i>
(also upon the element with the primary container Role)
</i>
must be dynamically updated to point to the currently selected child Role. For example, if the element including role="listbox" has focus, aria-activedescendant must be used to point to the currently highlighted element that includes role="option". If focus is set to the element that includes role="option" instead, then aria-activedescendant must not be included.
</p>
<p>
All of the above Roles that specify "including ancestor with the relevant Role", do not support the use of aria-activedescendant. This is true for all of the standalone Widget Roles as well, requiring that programmatic focus be set to each of these standalone Roles individually. The only exception to this is role="combobox", which supports the use of aria-activedescendant to reference the selected Option within an external Listbox control.
</p>
<p>
Whenever possible, Widget Roles should always reflect the intended functionality of the control type that is displayed.
</p>
<p>
At the same time, the
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles">Roles Model</a>
specification should always be reviewed in advance to ensure that the desired Widget Role matches the intended functionality of the control. This is important, because the Role name by itself may be misleading. For example, a Combobox must not reference a Menu, but instead must reference a Listbox, because the two are not functionally equivalent within Assistive Technologies.
</p>
</div>

<div class="hd">
<h3>
<span>
Compound Components
</span>
</h3>
</div>

<div class="intro tal">
<p>
Compound components occur when controls include more than one type of interactive Widget Role as part of their markup structure.
</p>
<p>
An example scenario for such a control is a keyboard accessible Grid, where the arrow keys can be used to navigate between each Gridcell, then by pressing Enter or Space, focus moves into the Gridcell to set focus to a series of form fields, or a Slider, or any number of other interactive control types.
</p>
<p>
Compound components are always challenging to implement, yet the following rules should always be observed when doing so.
</p>
<ul><li>
Ensure that all active elements are focusable and accessible from the keyboard.
</li><li>
Ensure that all focusable elements include valid Role mappings that are applicable to the control type.
</li><li>
Ensure that all focusable elements include explicit labels.
</li><li>
Ensure that the keyboard interaction design for accessing all focusable elements is logical.
</li><li>
Ensure that all keyboard interaction commands are fully documented and conveyed to the user; both for sighted keyboard only users and non-sighted screen reader users.
</li></ul>
<p>
Though this checklist addresses the most common issues associated with building compound components, it is more than likely that browser or Assistive Technology support bugs will be encountered during this process, so it is always important to test each component thoroughly during this process.
</p>
<p>
The first step for doing this, is to check the Accessibility Tree to verify that each focusable element is correctly mapped in the Accessibility API, and that each includes appropriate Role and State information for Assistive Technologies.
</p>
<p>
If the correct Widget Roles and States are applied to the elements that receive focus, but the Accessibility Tree is incorrect, then this needs to be reported to the company that owns the browser.
</p>
<p>
However, if the Accessibility Tree correctly reflects each Role and State for the control type, but the Assistive Technology is not conveying these correctly, then this needs to be reported to the Assistive Technology vender.
</p>
</div>

<div class="hd">
<h3>
<span>
Corner Cases
</span>
</h3>
</div>

<div class="intro tal">
<p>
Corner cases occur when a control doesn't specifically match any Widget Role in the Accessibility API, or when a particular Widget Role is not sufficient by itself to convey all necessary information to Assistive Technologies in the Accessibility Tree.
</p>
<p>
An example of the first can be seen at<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Date%20Pickers/ARIA%20Date%20Picker%20(with%20Disabled%20Date%20Ranges)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Date%20Pickers/ARIA%20Date%20Picker%20(with%20Disabled%20Date%20Ranges)/demo.htm</a><br />
Which is an interactive date picker control that includes disabled date ranges.
</p>
<p>
An interactive date picker such as this has no specific Widget Role however, and cannot be definitively mapped in the Accessibility API as a particular control type.
</p>
<p>
As a result, such a control usually becomes a compound component, because it includes embedded controls of differing types, as well as a corner case, because it includes active elements that don't resemble platform UI controls.
</p>
<p>
In this case, Link and Button Roles are used to represent each simulated active element within the date picker, even though they are not styled as such. This ensures that programmatic focus is always set to an element that maps to an active element Role in the Accessibility Tree, which is necessary to ensure accessibility for screen reader users.
</p>
<p>
The most important concept to keep in mind when implementing compound components and corner cases such as these, is to always map focusable elements to valid Roles, even if the Role doesn't necessarily match the visual styling.
</p>
<p>
The reason being, it is far more important to convey the correct Role and State of a control to Assistive Technology users, than it is to convey what it looks like.
</p>
<p>
The second type of corner case occurs when the correct usage of a Widget Role is not sufficient to convey all necessary information to Assistive Technology users.
</p>
<p>
An example of this can be seen at<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Data%20Grids/ARIA%20Data%20Grid%20(Dynamic)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Data%20Grids/ARIA%20Data%20Grid%20(Dynamic)/demo.htm</a><br />
Which is an interactive Grid control that moves programmatic focus between each Gridcell when the arrow keys are pressed.
</p>
<p>
The Grid however, displays two different types of information, a string value and a toggle value. The string value is styled as a label that includes the string, whereas the toggle is styled as a button with a pressed state.
</p>
<p>
A Gridcell is still a Gridcell however, and there is no way to convey differing pseudo role types such as these within the Accessibility Tree at the same time, since the Role always remains a Gridcell regardless. For example, if the Gridcell includes an element with role="button", and programmatic focus is set to it, it will break the navigability of the Grid for Assistive Technology users.
</p>
<p>
In this case, offscreen text is used to indicate the role of "button" and the state of "pressed", which is bound to the Gridcell using aria-labelledby. This conveys the pseudo role and state to screen readers without changing the Gridcell Role in the Accessibility Tree or compromising the keyboard interaction model.
</p>
<p>
As with all corner cases, there is no single solution to fit all situations, and every case is different.
</p>
<p>
Nevertheless, programmatic focus must always be set to elements that include valid Widget Roles to ensure accessibility for Assistive Technology users.
</p>
</div>

<div class="hd">
<h3>
<span id="8-25-2014-1" tabindex="-1">
Live Regions
</span>
</h3>
</div>

<div class="intro tal">
<p>
Live Regions occur when specific regions of a page are updated dynamically, and it's important to convey this information to Assistive Technology users. Reference:<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/terms#def_liveregion">http://www.w3.org/TR/wai-aria/terms#def_liveregion</a>
</p>
<p>
Implementing a Live Region is very simple, which can be accomplished using the aria-live attribute, in combination with aria-atomic and aria-relevant as needed.
</p>
<p>
Additionally, there are specific Roles that are dedicated as Live Regions, such as Alert, Log, and Status, yet there are important differences to be aware of regarding the use of each.
</p>
<p>
There are also some important caveats to be aware of regarding Live Region usage, that significantly impact accessibility.
</p>
</div>

<div class="hd">
<h4>
<span>
Aria-live Property
</span>
</h4>
</div>

<div class="intro tal">
<p>
The aria-live attribute is the simplest technique for creating a Live Region, documented at<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-live">http://www.w3.org/TR/wai-aria/states_and_properties#aria-live</a>
</p>
<p>
The attribute accepts three values, "off", "polite", or "assertive".
</p>
<p>
When set to "off", nothing is conveyed to Assistive Technology users when content is updated. When set to "polite", the new content is added to the speech queue so that current speech is not interrupted. When set to "assertive", the current speech queue might be cleared before the new content is announced, which could result in an interruption if Assistive Technologies have programmed this behavior.
</p>
<p>
Example:
</p>
<p>
<code>
&lt;div&gt;<br />
&lt;script type="text/javascript"&gt;<br />
var intVal = 0,<br />
intFN = function(){<br />
setInterval(function(){<br />
document.getElementById('tst1').innerHTML = (intVal++);<br />
}, 1000);<br />
};<br />
&lt;/script&gt;<br />
&lt;button onclick="intFN()"&gt; Test &lt;/button&gt;<br />
&lt;/div&gt;<br />
&lt;div aria-live="polite" id="tst1"&gt;&lt;/div&gt;
</code>
</p>
<p>
Live demo:<br />
<a target="_blank" href="http://whatsock.com/training/demos/lr/aria-live-polite.html">http://whatsock.com/training/demos/lr/aria-live-polite.html</a>
</p>
<p>
There are two other attributes that dictate how aria-live behaves when set to either "polite" or "assertive", which are
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-atomic">aria-atomic</a>
and
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-relevant">aria-relevant</a>.
</p>
<p>
When aria-atomic is undefined or set to "false", only the newest text should be announced when added to a Live Region container, regardless whether the container contains additional text or not. This is the default behavior when aria-atomic is not included with the aria-live attribute.
</p>
<p>
When aria-atomic is set to "true" however, all of the text should be announced when new text is added to the Live Region container, every time the container is updated.
</p>
<p>
Example:
</p>
<p>
<code>
&lt;div&gt;<br />
&lt;script type="text/javascript"&gt;<br />
var intVal = 0,<br />
intFN = function(){<br />
setInterval(function(){<br />
document.getElementById('tst1').appendChild(document.createTextNode(' ' + intVal++));<br />
}, 1000);<br />
};<br />
&lt;/script&gt;<br />
&lt;button onclick="intFN()"&gt; Test &lt;/button&gt;<br />
&lt;/div&gt;<br />
&lt;div aria-live="polite" aria-atomic="true" id="tst1"&gt;&lt;/div&gt;
</code>
</p>
<p>
Live demo:<br />
<a target="_blank" href="http://whatsock.com/training/demos/lr/announce%20all/aria-atomic-true.html">http://whatsock.com/training/demos/lr/announce%20all/aria-atomic-true.html</a>
</p>
<p>
The
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-relevant">aria-relevant</a>
attribute controls the type of information that is announced, and may be set to "additions", "removals", "text", "all", or a space delimited list of individual token values. For instance, the default value for aria-relevant is "additions text" when aria-live is set, specifying that only newly added text should be announced.
</p>
<p>
When aria-relevant is set to "removals", only removed text nodes should be announced, and not newly added text.
</p>
<p>
Example:
</p>
<p>
<code>
&lt;div&gt;<br />
&lt;script type="text/javascript"&gt;<br />
var intVal = 0,<br />
intFN = function(){<br />
setInterval(function(){<br />
document.getElementById('tst1').innerHTML = (intVal++);<br />
}, 1000);<br />
};<br />
&lt;/script&gt;<br />
&lt;button onclick="intFN()"&gt; Test &lt;/button&gt;<br />
&lt;/div&gt;<br />
&lt;div aria-live="polite" aria-relevant="removals" id="tst1"&gt;&lt;/div&gt;
</code>
</p>
<p>
Live demo:<br />
<a target="_blank" href="http://whatsock.com/training/demos/lr/aria-live-polite-removals.html">http://whatsock.com/training/demos/lr/aria-live-polite-removals.html</a>
</p>
</div>

<div class="hd">
<h4>
<span>
Alert Role
</span>
</h4>
</div>

<div class="intro tal">
<p>
The Alert Role is an especially aggressive type of Live Region, which is always important to be aware of. Reference:<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#alert">http://www.w3.org/TR/wai-aria/roles#alert</a>
</p>
<p>
Relevant Live Region attributes: aria-live="assertive" and aria-atomic="true"
</p>
<p>
When set, the Alert Role ties into the alert system on the Operating System, causing system wide alerts to fire and interrupt speech, no matter where focus is set, even while interacting with unrelated applications.
</p>
<p>
Example:
</p>
<p>
<code>
&lt;div&gt;<br />
&lt;script type="text/javascript"&gt;<br />
var intVal = 0,<br />
intFN = function(){<br />
setInterval(function(){<br />
document.getElementById('tst1').innerHTML = (intVal++);<br />
}, 1000);<br />
};<br />
&lt;/script&gt;<br />
&lt;button onclick="intFN()"&gt;<br /> Test &lt;/button&gt;<br />
&lt;/div&gt;<br />
&lt;div role="alert" id="tst1"&gt;&lt;/div&gt;
</code>
</p>
<p>
Live demo:<br />
<a target="_blank" href="http://whatsock.com/training/demos/lr/announce%20all/role-alert.html">http://whatsock.com/training/demos/lr/announce%20all/role-alert.html</a>
</p>
<p>
To hear this in action, run JAWS on Windows, open the above test page and activate the Test button, then attempt to interact with any other application on your computer while the test page is running.
</p>
<p>
Notice that speech is constantly interrupted, and it is impossible to interact effectively with any application on the Operating System.
<i>
(Verified using JAWS15 on Win7)
</i>
</p>
<p>
For this reason, the Alert Role should always be used sparingly, and to convey critical information only.
</p>
</div>

<div class="hd">
<h4>
<span>
Log and Status Roles
</span>
</h4>
</div>

<div class="intro tal">
<p>
Though used for different purposes, the Log and Status Roles include the same Live Region functionality as aria-live="polite".
</p>
<p>
The Log Role is used for Live Regions that include incrementally updated content, such as chat logs, message histories, and so on. Reference:<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#log">http://www.w3.org/TR/wai-aria/roles#log</a>
</p>
<p>
The Status Role is used to present dynamically changing status messages to users, that are not important enough to warrant the use of an Alert Role. Reference:<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#status">http://www.w3.org/TR/wai-aria/roles#status</a>
</p>
<p>
Relevant Live Region attributes: aria-live="polite" and aria-atomic="false"
</p>
<p>
Live demos:<br />
<a target="_blank" href="http://whatsock.com/training/demos/lr/announce%20new%20text%20only/role-log.html">http://whatsock.com/training/demos/lr/announce%20new%20text%20only/role-log.html</a><br />
And<br />
<a target="_blank" href="http://whatsock.com/training/demos/lr/announce%20new%20text%20only/role-status.html">http://whatsock.com/training/demos/lr/announce%20new%20text%20only/role-status.html</a>
</p>
<p>
At the time of this writing (08/25/2014), neither the Log nor Status Roles are well supported across browsers and ATs, especially using JAWS in IE.
<i>
(Verified using JAWS15 in IE11 on Win7)
</i>
</p>
</div>

<div class="hd">
<h4>
<span>
Live Region Caveats
</span>
</h4>
</div>

<div class="intro tal">
<p>
Besides the previously covered issues with the Alert Role, there are additional caveats to be aware of regarding the use of Live Regions.
</p>
<ul><li>
When Live Region text is announced using a screen reader such as JAWS, NVDA, or VoiceOver, the same voice is used to do so. This means that, when a user is navigating using the arrow keys or by any other navigational keystroke to read the page, there is no way for the user to differentiate the content that is being automatically announced from the text that is announced as part of standard navigation, which is often extremely confusing to the user.
<br /><br />
This is why Live Regions should never be applied to auto-rotating carousels, nor to frequently updated content such as stock tickers without a dedicated checkbox for enabling this functionality by the user as a toggleable feature if desired.
<br /><br />
This is also why Live Regions should never be over-used within web technologies.
</li><li>
As you may have noticed in the previous live demos when testing the differences between IE and Firefox using JAWS and NVDA, support for Live Regions varies greatly depending on the combination of Properties and Roles that are used.
<br /><br />
For example, as of 08/25/2014 using JAWS, neither the Log nor Status Roles are supported in IE, nor does aria-live="polite" announce only the newest text node when dynamically added to a Live Region in IE, nor does JAWS announce only the removed text node when aria-relevant="removals" in IE.
<i>
(Verified using JAWS15 in IE11 on Win7)
</i>
<br /><br />
As a result, the most widely supported technique at present, is to use innerHTML to update the content of a Live Region that includes aria-live="polite" or aria-live="assertive", with the intent of announcing the full content to Assistive Technology users.
<br /><br />
Example:
<br /><br />
<code>
&lt;div&gt;<br />
&lt;script type="text/javascript"&gt;<br />
var intVal = 0,<br />
intFN = function(){<br />
setInterval(function(){<br />
document.getElementById('tst1').innerHTML = (intVal++);<br />
}, 1000);<br />
};<br />
&lt;/script&gt;<br />
&lt;button onclick="intFN()"&gt; Test &lt;/button&gt;<br />
&lt;/div&gt;<br />
&lt;div aria-live="polite" id="tst1"&gt;&lt;/div&gt;
</code>
<br /><br />
Live demo:<br />
<a target="_blank" href="http://whatsock.com/training/demos/lr/aria-live-polite.html">http://whatsock.com/training/demos/lr/aria-live-polite.html</a>
</li><li>
Whenever text is announced as part of a Live Region, or in any other manner such as through an explicit label or description via aria-label/aria-labelledby/aria-describedby, the announced text will always use the Assistive Technology's current punctuation and pronunciation settings; thus making it impossible to guarantee that specific punctuation symbols or capitalization will be announced.
<br /><br />
Thus, neither Live Regions nor ARIA labelling mechanisms should ever be relied upon to convey case sensitive or punctuation dependent information to Assistive Technology users.
</li></ul>
</div>

</div>

<div role="region" aria-label="Accessibility Tree versus DOM">

<div class="hd">
<h2>
<span>
Accessibility Tree versus DOM
</span>
</h2>
</div>

<div class="intro tal">
<p>
It's very important to understand that the Accessibility Tree and the Document Object Model (DOM) are not the same thing.
</p>
<p>
The DOM is what browsers use to render content, and the DOM is where all dynamic HTML content is controlled through scripting.
</p>
<p>
The specification that browsers use for building the DOM is available at<br />
<a target="_blank" href="http://www.w3.org/DOM/DOMTR">http://www.w3.org/DOM/DOMTR</a>
</p>
<p>
An excellent resource for developers to reference regarding DOM functionality support across browsers, is the Quirksmode DOM Core index, available at<br />
<a target="_blank" href="http://quirksmode.org/dom/core/">http://quirksmode.org/dom/core/</a><br />
Which should always be consulted to ensure cross browser compatibility when working with plain JavaScript.
</p>
<p>
When a webpage is loaded within a browser, it parses the HTML markup of the page and builds a DOM as a live representation of the page. The DOM is represented as a tree, with the top level node being the documentElement. All subsequent child nodes represent the various elements that branch off from that, including the HEAD and BODY. Within the BODY node is where all visually rendered content is displayed using the browser; also represented as child nodes in the DOM.
</p>
<p>
JavaScript can then be used to change, add, or remove nodes in the DOM, causing the visual display to change dynamically. Many other things can be done with the DOM using JavaScript as well, such as adding, removing, or triggering events for user interaction, pulling in content from external resources through AJAX so it can be added to the DOM, handling focus movement for custom control types, and so on.
</p>
<p>
Basically, the DOM is where all of the action happens when you interact with dynamic web technologies.
</p>
<p>
So here is the really important bit, the browser uses the DOM in order to populate what the Accessibility Tree contains for Assistive Technologies.
</p>
<p>
The DOM itself has no direct access to the Accessibility Tree, nor is it possible to access the Accessibility Tree using JavaScript at this time.
</p>
<p>
The order of precedence is as follows:
</p>
<ol><li>
The browser builds a DOM using HTML markup from the server.
</li><li>
The browser builds an Accessibility Tree using the DOM.
</li><li>
Assistive Technologies interface with the Accessibility Tree to customize functionality for the user.
</li><li>
The DOM changes as users interact with dynamic content.
</li><li>
The browser responds to events caused by these DOM changes and updates the Accessibility Tree accordingly.
</li><li>
Assistive Technologies recognize that the Accessibility Tree has changed when related events are fired, and convey these changes to the user.
</li></ol>
<p>
This is why one control on a particular browser may be represented differently in the Accessibility Tree on another browser, even though both browsers are running on the same Operating System; using the same code.
</p>
<p>
An example of this can be seen at<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Trees/Tree%20(External%20XML)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Trees/Tree%20(External%20XML)/demo.htm</a><br />
Which is an ARIA Tree construct.
</p>
<ol><li>
Using IE11, if you look at the Accessibility Tree object for the focusable 'treeitem' node, you will see that the Role is "outline item" (36), the State is "SELECTED FOCUSED COLLAPSED FOCUSABLE SELECTABLE LINKED" (7341062), the Name is "ACT I", and the Description is "1 of 4".
</li><li>
Using Firefox, if you look at the Accessibility Tree object for the same control, you will see that the Role is "outline item" (36), the State is "SELECTED FOCUSED COLLAPSED FOCUSABLE SELECTABLE" (3146758), the Name is "ACT I", and the Description is "".
</li><li>
Using Chrome, if you look at the Accessibility Tree object for the same control, you will see that the Role is "outline item" (36), the State is "SELECTED FOCUSED FOCUSABLE" (1048582), the Name is "ACT I", and the Description is "".
</li></ol>
<p>
<i>
(Verified using Windows7 on 07/12/2014)
</i>
</p>
<p>
As you can see, this identifies a bug in Chrome, where COLLAPSED is not included as part of the State, providing no way for Assistive Technologies to recognize a difference between branch and leaf nodes using the Accessibility Tree.
</p>
<p>
<i>
(I'll report this to Google and hopefully it will be fixed soon.)
</i>
</p>
<p>
You can also see that the Description is populated using IE, but not using Firefox or Chrome, which is worth asking about as well.
</p>
<p>
This illustrates an important point, whenever the markup is correct, but inconsistencies are discovered in the Accessibility Tree, they must be reported to the company that owns the browser.
</p>
<p>
Similarly, if the markup and Accessibility Tree is correct, but the Assistive Technology is not conveying this to the end user, then this must be reported to the Assistive Technology vender.
</p>
</div>

</div>

<div role="region" aria-label="Keyboard, Touch, and ATs">

<div class="hd">
<h2>
<span>
Keyboard, Touch, and ATs
</span>
</h2>
</div>

<div class="intro tal">
<p>
Since Assistive Technology behaviors and support levels differ, it is always important to consider your target audience.
</p>
<p>
This is especially true for progressive enhancement, where the same controls may be used across both desktop and mobile devices; subject to both keyboard and touch interaction.
</p>
<p>
In order to ensure maximum accessibility for the highest percentage of people possible, it is always important to know the idiosyncrasies of the most widely used Assistive Technologies.
</p>
<p>
A good resource for checking the latest screen reader usage statistics, is the WebAIM: Screen Reader User Survey, available at<br />
<a target="_blank" href="http://webaim.org/search/?q=Screen%20Reader%20User%20Survey">http://webaim.org/search/?q=Screen%20Reader%20User%20Survey</a>
</p>
<p>
Currently:
</p>
<ul><li>
JAWS and NVDA on Windows desktops and laptops are the most widely used screen readers for people with blindness.
</li><li>
VoiceOver on iOS is the most widely used mobile touch screen device screen reader for people with blindness.
</li><li>
Dragon NaturallySpeaking is the most widely used voice navigation software for people with motor impairments.
</li><li>
ZoomText is the most widely used screen magnification software for people with low vision.
</li></ul>
</div>

<div class="hd">
<h3>
<span>
Keyboard Accessibility
</span>
</h3>
</div>

<div class="intro tal">
<p>
The first thing that must always be covered is keyboard accessibility.
</p>
<p>
All interactive controls within web technologies must be actionable using the keyboard. There should be no functionality that can only be achieved using the mouse.
</p>
<p>
This should always be addressed before even considering the use of ARIA.
</p>
<p>
It's important to note that this doesn't refer to the practice of adding all active elements to the tab order.
</p>
<p>
Keyboard functionality should always match the closest platform equivalent for that control type, since this is how simulated controls are mapped in the Accessibility Tree when ARIA is applied.
</p>
<p>
This is why a standard right-click context menu has only one tab stop, uses the arrow keys to navigate within the control, and then closes when the Tab or Escape key is pressed.
</p>
<p>
Here is an example of a complex control type, a Data Grid:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Data%20Grids/ARIA%20Data%20Grid%20(Dynamic)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Data%20Grids/ARIA%20Data%20Grid%20(Dynamic)/demo.htm</a><br />
Within which are many active elements, since each data cell is actionable.
</p>
<p>
Nevertheless, the grid itself has only one tab stop.
</p>
<p>
When building complex interactive components, the technique of setting focus to the control with one tab stop, allows keyboard only users to easily navigate past the control by pressing Tab again if they don't wish to interact with the control using the arrow keys; thus aiding navigation.
</p>
<p id="9-2-2014-1" tabindex="-1">
More examples of this design pattern include all of the following:
</p>
<ul><li>
ARIA Tabs:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20and%20Non-ARIA%20Tabs/ARIA%20Tabs%20(Internal%20Content)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20and%20Non-ARIA%20Tabs/ARIA%20Tabs%20(Internal%20Content)/demo.htm</a>
</li><li>
ARIA Listboxes:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Listboxes/Multiselect/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Listboxes/Multiselect/demo.htm</a>
</li><li>
ARIA Menus:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Menus/Vertical%20(Internal%20Content)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Menus/Vertical%20(Internal%20Content)/demo.htm</a>
</li><li>
ARIA Radio Buttons:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Radio%20Buttons/ARIA%20Radio%20Buttons/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Radio%20Buttons/ARIA%20Radio%20Buttons/demo.htm</a>
</li><li>
ARIA Trees:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Trees/Tree%20(External%20XML)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Trees/Tree%20(External%20XML)/demo.htm</a>
</li></ul>
<p>
Additionally, these keyboard requirements are more fully described at<br />
<a target="_blank" href="https://www.ssbbartgroup.com/blog/2013/10/22/why-there-are-only-two-ways-to-make-aria-widgets-programmatically-focusable-for-screen-reader-users/">https://www.ssbbartgroup.com/blog/2013/10/22/why-there-are-only-two-ways-to-make-aria-widgets-programmatically-focusable-for-screen-reader-users/</a><br />
Which all developers should be familiar with in order to apply the correct focus movement plus ARIA attributes with the correct design pattern.
</p>
<p>
It is also important to note the differences between native active elements and simulated active elements, and how events are triggered differently for each.
</p>
<p>
Native active elements are automatically recognized by the browser as being actionable, and keyboard accessibility for these controls is handled automatically as well.
</p>
<p>
A native active element is any standard form field:<br />
<a target="_blank" href="http://www.w3.org/TR/html401/interact/forms.html#h-17.2.1">http://www.w3.org/TR/html401/interact/forms.html#h-17.2.1</a><br />
Or any standard link:<br />
<a target="_blank" href="http://www.w3.org/TR/html401/struct/links.html#edef-A">http://www.w3.org/TR/html401/struct/links.html#edef-A</a>
</p>
<p>
<i>
(A standard link will only become keyboard accessible as a link when it includes an "href" attribute. An A tag that includes tabindex="0" instead, will be treated as a simulated active element, and not a native active element.)
</i>
</p>
<p>
A simulated active element, is any other static element type that is used in place of a standard link or form field, such as a DIV or SPAN.
</p>
<p>
A native active element such as a standard link or button is already keyboard accessible, and will automatically process the onClick handler when attached, even when Enter is pressed using the keyboard.
</p>
<p>
However, a simulated active element such as a DIV or SPAN will not trigger an onClick handler when Enter is pressed using the keyboard. Instead, tabindex must be used to manage focus movement, and a redundant onKeyUp or onKeyPress must be added in addition to the onClick handler, in order to ensure accessibility for both sighted mouse users and keyboard only users.
</p>
<p>
<i>
(The reason why onKeyUp is preferable to onKeyDown in such cases, is because onKeyDown will fire repeatedly when a key is held down, but onKeyUp will not.)
</i>
</p>
<p>
This technique is more fully described at<br />
<a target="_blank" href="http://www.w3.org/TR/WCAG20-TECHS/SCR29.html#SCR29-description">http://www.w3.org/TR/WCAG20-TECHS/SCR29.html#SCR29-description</a>
</p>
<p>
A simple example of the process involved in making simulated buttons accessible, is available at<br />
<a target="_blank" href="http://whatsock.com/training/demos/buttons.html">http://whatsock.com/training/demos/buttons.html</a><br />
Where, only the last button listed is fully accessible. Notice also that the last button (4) is the only one that has a correct Role mapping in the Accessibility Tree.
</p>
</div>

<div class="hd">
<h3>
<span>
JAWS For Windows
</span>
</h3>
</div>

<div class="intro tal">
<p>
Since JAWS is one of the most widely used screen readers on the Windows Operating System, it's important to understand how it works.
</p>
<p>
First, the following article should be read:<br />
<a target="_blank" href="http://www.freedomscientific.com/Support/TechnicalSupport/Bulletin/1404">http://www.freedomscientific.com/Support/TechnicalSupport/Bulletin/1404</a><br />
Which provides a good idea how JAWS works within web technologies.
</p>
<p>
One important thing to note is that, the above referenced article was written for JAWS 11, and the behavior of role=application as described, significantly changed in later versions of JAWS. For instance, support for role=application was removed in JAWS 12 and 13, and was partially reintroduced in 14 and 15. Now, JAWS will enter Forms Mode when focus is set within an Application region, but can be exited back into Virtual Cursor mode as with any other web content by pressing NumPad+ or Escape. In this way, Applications Mode currently acts the same as Forms Mode.
</p>
<p>
Also, the article mentions Auto Forms Mode. This is often disabled by many power users however as an annoyance, so both modes should be tested for, one with Auto Forms Mode enabled, and another with it disabled.
</p>
<p>
<i>
(This setting can be found within the Verbosity Dialog, by pressing Insert+V while focus is on a web page.)
</i>
</p>
<p>
Important things to know about event triggering using JAWS:
</p>
<ul><li>
When JAWS is in Virtual Cursor Mode for navigating web content, JAWS will activate the onClick event when the Enter key is pressed on an element.
</li><li>
When JAWS is in Applications/Forms Mode however, JAWS will activate the onKeyDown/onKeyPress/onKeyUp events instead, and not the onClick.
</li></ul>
<p>
For native active elements such as standard links and buttons, this usually causes no problems.
</p>
<p>
For simulated active elements such as when using DIV or SPAN elements however, this often comes into play.
</p>
<p>
Within the latest version of JAWS, it is possible to change the event passed through when Enter is pressed while the Virtual Cursor is active, to 'Send the Enter key' instead of simulating a mouse click. This too is done within the Verbosity Dialog, under Link Activation. Nevertheless, this setting is never on by default, and should never be relied upon as an alternative.
</p>
<p>
When JAWS is in Virtual Cursor Mode, it reads all offscreen content, even if other content is overlayed across it.
</p>
<p>
When this happens, if Enter is pressed, JAWS will activate an onClick using the coordinates of the content JAWS is announcing, but will instead be clicking whatever content is overlayed across it.
</p>
<p>
When the Down arrow is pressed to navigate through web content using the Virtual Cursor, JAWS will not trigger the onFocus handler if attached to any focusable elements. The only exception to this is when Auto Forms Mode is activated automatically on some form fields.
</p>
<p>
Regarding support, JAWS often works best in Internet Explorer, and secondarily in Firefox with slightly less support. JAWS does not often work well in Chrome, especially with interactive ARIA Widgets.
</p>
</div>

<div class="hd">
<h3>
<span>
NonVisual Desktop Access
</span>
</h3>
</div>

<div class="intro tal">
<p>
Since NVDA is the second most widely used screen reader on Windows, understanding how it works is also important.
</p>
<p>
If you understand how JAWS works using the Virtual Cursor Mode and Applications/Forms Mode to navigate web content, then you will easily understand NVDA.
</p>
<p>
Instead of Virtual Cursor Mode, NVDA uses Browse Mode, and instead of Forms Mode, NVDA uses Applications Mode, but they are equivalent to each other.
</p>
<p>
For further details regarding the use of NVDA, visit<br />
<a target="_blank" href="http://www.marcozehe.de/articles/how-to-use-nvda-and-firefox-to-test-your-web-pages-for-accessibility/">http://www.marcozehe.de/articles/how-to-use-nvda-and-firefox-to-test-your-web-pages-for-accessibility/</a>
</p>
<p>
All of the caveats that were listed for JAWS also apply for NVDA:
</p>
<ul><li>
When NVDA is in Browse Mode for navigating web content, NVDA will activate the onClick event when the Enter key is pressed on an element.
</li><li>
When NVDA is in Applications Mode however, NVDA will activate the onKeyDown/onKeyPress/onKeyUp events instead, and not the onClick.
</li></ul>
<p>
When NVDA is in Browse Mode, it reads all offscreen content, even if other content is overlayed across it.
</p>
<p>
When this happens, if Enter is pressed, NVDA will activate an onClick using the coordinates of the content NVDA is announcing, but will instead be clicking whatever content is overlayed across it.
</p>
<p>
Here is an important difference between JAWS and NVDA however.
</p>
<p>
When the Down arrow is pressed to navigate through web content using Browse Mode, NVDA will automatically trigger the onFocus handler if attached to any focusable elements.
</p>
<p>
This definitely comes into play when building ARIA Widgets that have one tab stop and require the use of the arrow keys to switch focus between them.
</p>
<p>
Here is an example that shows why this is important to be aware of:<br />
<a target="_blank" href="http://whatsock.com/training/demos/radios.html">http://whatsock.com/training/demos/radios.html</a><br />
Which is an ARIA Radio control that incorrectly uses onFocus instead of onClick to trigger selection.
</p>
<p>
As opposed to:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Radio%20Buttons/ARIA%20Radio%20Buttons/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Radio%20Buttons/ARIA%20Radio%20Buttons/demo.htm</a><br />
Which correctly uses onClick to trigger selection.
</p>
<p>
Regarding support, NVDA often works best in Firefox, and secondarily in Internet Explorer with less support. NVDA does not often work well in Chrome, especially with interactive ARIA Widgets.
</p>
</div>

<div class="hd">
<h3>
<span>
VoiceOver on iOS
</span>
</h3>
</div>

<div class="intro tal">
<p>
Since VoiceOver is the most widely used screen reader on mobile devices such as the iPad and iPhone, understanding how this differs from other screen readers is important as well.
</p>
<p>
Firstly, unlike JAWS and NVDA, VoiceOver has no offscreen model for browsing.
</p>
<p>
This means that VoiceOver can only access what is visually rendered in the viewport, and nothing else that is hidden offscreen or behind layered content.
</p>
<p>
There is one exception regarding offscreen content though, which is the practice of positioning a container element offscreen, assigning it as a live region using ARIA, and then programmatically using it to announce status messages with VoiceOver.
</p>
<p>
An example of this can be seen at:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/Web%20Chat%20and%20Dynamic%20Message%20Announcement/Web%20Chat%20(Static)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/Web%20Chat%20and%20Dynamic%20Message%20Announcement/Web%20Chat%20(Static)/demo.htm</a><br />
Which is a basic dynamic chat demo.
</p>
<p>
<i>
(As messages are typed, both the 'now typing' status and new message text when it arrives, are announced by VoiceOver using this technique.)
</i>
</p>
<p>
The problem with the most common offscreen styling however, is that the CSS left and top properties are used to position the live region outside of the viewport bounds.
</p>
<p>
If the live region includes an ARIA Role, or has a tabindex value, it is sometimes possible to get VoiceOver to accidentally focus upon the region, causing the screen to flip into some blank area that it can't return from, rendering the page unusable.
</p>
<p>
There is only one CSS class that prevents this from occurring, which should always be used when including offscreen content as part of progressive enhancement across devices.
</p>
<p>
<code>
.offscreenText {<br />
position: absolute;<br />
clip: rect(1px1px1px1px); /* IE6, IE7 */<br />
clip: rect(1px, 1px, 1px, 1px);<br />
padding: 0;<br />
border: 0;<br />
height: 1px; <br />
width: 1px; <br />
overflow: hidden;<br />
z-index: -1000;<br />
}
</code>
</p>
<p>
This styling configuration is based on the research done by Thierry Koblentz, which is more fully described at<br />
<a target="_blank" href="https://developer.yahoo.com/blogs/tenydnblog/clip-hidden-content-better-accessibility-53456.html">https://developer.yahoo.com/blogs/tenydnblog/clip-hidden-content-better-accessibility-53456.html</a>
</p>
<p>
Regarding event triggering, using VoiceOver by touch to announce content on the page, will automatically trigger the onFocus handler when VoiceOver reads the content, and will automatically trigger the onBlur handler when focus moves away.
</p>
<p>
This comes into play when implementing progressively enhanced ARIA Menus for example, which may be designed to disappear when focus moves out of the menu, as would be seen on standard desktop machines for keyboard usage.
</p>
</div>

<div class="hd">
<h3>
<span>
Dragon NaturallySpeaking
</span>
</h3>
</div>

<div class="intro tal">
<p>
For people who require voice navigation software due to motor impairments, Dragon is the most widely used.
</p>
<p>
Historically, nothing that was built using simulated controls was represented as they are mapped in the Accessibility Tree using ARIA.
</p>
<p>
The following post explains why:<br />
<a target="_blank" href="http://blog.paciellogroup.com/2013/11/short-note-aria-dragon-accessibility/">http://blog.paciellogroup.com/2013/11/short-note-aria-dragon-accessibility/</a>
</p>
<p id="7-24-2014-2" tabindex="-1">
Recent efforts have been made that may help with this in the future however, as documented at<br />
<a target="_blank" href="http://www.speechtechmag.com/Articles/News/Speech-Technology-News-Features/Nuance-Dragon-NaturallySpeaking-13-Promises-Greater-Speed-and-Accuracy-98295.aspx">http://www.speechtechmag.com/Articles/News/Speech-Technology-News-Features/Nuance-Dragon-NaturallySpeaking-13-Promises-Greater-Speed-and-Accuracy-98295.aspx</a>
</p>
<blockquote>
Drilling down to a more technical level, Mahoney says Dragon was able to revamp its ability to interact with Web applications by leveraging the accessibility standard for Web applications, ARIA (Accessible Rich Internet Applications).<br />
"Most well-formed HTML can be speakable," Mahoney says. "We have good compatibility with well-formed standard HTML. Anyone who leverages the ARIA standard gets very good operability with voice commands with Dragon. Basically, it identifies and names the controls on a Web page so that an external application can communicate with [Dragon]."
</blockquote>
<p>
Regardless of ARIA support, it is still possible to make simulated controls accessible for Dragon users.
</p>
<p>
This goes back to keyboard accessibility, and why it is so important to ensure that all controls are keyboard accessible and follow the design pattern for the equivalent Operating System control type.
</p>
<p>
It may seem non-intuitive that ensuring keyboard accessibility is so important for people who can't use a keyboard, but here is the reason why.
</p>
<p>
Dragon users have the ability to voice specific key commands in order to control keyboard functionality through speech.
</p>
<p>
Here is a complex control type that demonstrates this functionality:<br />
<a target="_blank" href="http://whatsock.com/tsg/Coding%20Arena/ARIA%20Date%20Pickers/ARIA%20Date%20Picker%20(with%20Disabled%20Date%20Ranges)/demo.htm">http://whatsock.com/tsg/Coding%20Arena/ARIA%20Date%20Pickers/ARIA%20Date%20Picker%20(with%20Disabled%20Date%20Ranges)/demo.htm</a><br />
Which is a keyboard accessible Date Picker control.
</p>
<p>
Voice navigation commands for Dragon include the following after the date picker is opened:
</p>
<ul><li>
'press up' or 'press down' to navigate by week.
</li><li>
'press left' or 'press right' to navigate by day.
</li><li>
'press home' or 'press end' to navigate to the beginning or end of a week.
</li><li>
'press pageDown' or 'press pageUp' to navigate by month.
</li><li>
'press enter' to save a date and close the date picker.
</li><li>
'press escape' or 'press tab' to cancel and close the date picker without saving.
</li></ul>
<p>
Comprehensive keyboard support is critical for all interactive web technologies.
</p>
</div>

<div class="hd">
<h3>
<span>
ZoomText
</span>
</h3>
</div>

<div class="intro tal">
<p>
For people with low or partial vision, ZoomText is the most widely used screen magnification software.
</p>
<p>
Regarding ARIA support, the following is stated at<br />
<a target="_blank" href="http://www.aisquared.com/support/more/zoomtext_100_release_notes">http://www.aisquared.com/support/more/zoomtext_100_release_notes</a>
</p>
<blockquote>
Support for ARIA and HTML5 in Internet Explorer 9 (IE9) When using Internet Explorer 9 (IE9), ZoomText now supports: ARIA landmarks and HTML5 tags for navigating page sections when using Web Finder, ARIA roles and attributes for announcing clearer descriptions of web page controls and other elements, and ARIA live regions to track and announce pop up bars and alerts (enabled by the Alert check boxes in ZoomText's Program Echo and Navigation &gt; Tracking dialog boxes).
</blockquote>
<p>
This is good, but currently limited.
</p>
<p>
Since those using screen magnification software have some vision, it shouldn't be an issue for users to recognize specific control types as long as the layout is intuitive, the styling represents a recognizable control type, and the color contrast is sufficient.
</p>
<p>
Specific to ARIA, it's important to note that the use of aria-label or aria-labelledby to reference offscreen text, will not be conveyed to screen magnification software users.
</p>
<p>
Reference:<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-label">http://www.w3.org/TR/wai-aria/states_and_properties#aria-label</a><br />
And<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/states_and_properties#aria-labelledby">http://www.w3.org/TR/wai-aria/states_and_properties#aria-labelledby</a>
</p>
<p>
The naming calculation that browsers use for these attributes, is documented at<br />
<a target="_blank" href="http://www.w3.org/TR/wai-aria/roles#textalternativecomputation">http://www.w3.org/TR/wai-aria/roles#textalternativecomputation</a><br />
Which is always good to be familiar with.
</p>
<p>
Lastly, when a Label element is used to set an explicit label for a form field by matching their For and ID attributes, as documented at<br />
<a target="_blank" href="http://www.w3.org/TR/WCAG20-TECHS/H44.html#H44-description">http://www.w3.org/TR/WCAG20-TECHS/H44.html#H44-description</a><br />
A user can click on the visible label and activate the form field.
</p>
<p>
This is often helpful for many different user types.
</p>
<p>
If the aria-labelledby attribute is used to set an explicit form field label instead however, this functionality will not be available.
</p>
</div>

</div>

<div role="region" aria-label="Sharing and Contact Info">

<div class="hd">
<h2>
<span>
Sharing and Contact Info
</span>
</h2>
</div>

<div class="intro tal">
<p>
Please feel free to print or redistribute this training guide in any way that you wish.
</p>
<p>
If you have noticed anything that is incorrect, or that should be added, please <a id="mlto" href="#" target="_blank">contact me</a> directly instead of modifying the information provided here, so that this information can be updated appropriately for others.
</p>
<p>
Sincerely,
</p>
<p>
<a href="http://www.linkedin.com/in/bgaraventa/" target="_blank">Bryan Garaventa</a>
</p>
</div>

</div>

<div role="region" aria-label="Change Log">

<div class="hd">
<h2>
<span>
Change Log
</span>
</h2>
</div>

<div class="intro tal">
<dl>
<dt role="heading" aria-level="3">
07/22/2014
</dt>
<dd>
Initial Release.
</dd>
<dt role="heading" aria-level="3">
07/24/2014
</dt>
<dd>
Within section ARIA Categories &gt; Landmarks and Regions &gt; Region Role:
<a href="#" onclick="document.getElementById('7-24-2014-1').focus();return false;">
Added Scrollable Divs subsection.
</a>
<br />
Within section Keyboard, Touch, and ATs &gt; Dragon NaturallySpeaking:
<a href="#" onclick="document.getElementById('7-24-2014-2').focus();return false;">
Updated ARIA support section to reflect recent press release.
</a>
</dd>
<dt role="heading" aria-level="3">
08/01/2014
</dt>
<dd>
Within section ARIA, Important Details:
<a href="#" onclick="document.getElementById('8-1-2014-1').focus();return false;">
Added ARIA Drag and Drop subsection.
</a>
</dd>
<dt role="heading" aria-level="3">
08/15/2014
</dt>
<dd>
Within section Accessibility API &gt; Simulated Web Controls using ARIA:
<a href="#" onclick="document.getElementById('8-15-2014-1').focus();return false;">
Added Microsoft ARIA to UIA Role and Property mapping references.
</a>
</dd>
<dt role="heading" aria-level="3">
08/18/2014
</dt>
<dd>
Within section Accessibility API &gt; User Agent Implementation Guide:
<a href="#" onclick="document.getElementById('8-18-2014-1').focus();return false;">
Fixed UAIG Introduction url to point to the correct page. 
</a>
<i>
(Reported by: Mark Sadecki)
</i>
</dd>
<dt role="heading" aria-level="3">
08/25/2014
</dt>
<dd>
Within section ARIA Categories:
<a href="#" onclick="document.getElementById('8-25-2014-1').focus();return false;">
Added Live Regions subsection.
</a>
</dd>
<dt role="heading" aria-level="3">
<span class="footnote" id="f1"></span>
09/02/2014
</dt>
<dd>
Within section Keyboard, Touch, and ATs &gt; Keyboard Accessibility:
<a href="#" onclick="document.getElementById('9-2-2014-1').focus();return false;">
Added direct design pattern demos.
</a>
</dd>
</dl>
</div>

</div>

</div>
</div>

<div class="topLink">
<a href="#"><img src="img/up.png" title="Back to Top" alt="Back to Top" /></a>
</div>

<div class="copyright">
<span>
&copy;2010-2014 WhatSock, LLC;
All rights reserved.
</span>
</div>

</div>
</body>
</html>